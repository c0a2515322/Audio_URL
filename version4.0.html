<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éŸ³éŸ¿é€šä¿¡ã‚·ã‚¹ãƒ†ãƒ  (Final Version)</title>
    <script src="dsp.js"></script>
    <style>
        body {
            font-family: sans-serif;
            padding: 1em;
            margin: 0;
        }

        .container {
            max-width: 600px;
            margin: auto;
        }

        .section {
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .warning-box {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>éŸ³éŸ¿é€šä¿¡ã‚·ã‚¹ãƒ†ãƒ  (Final Version)</h1>
        <div class="warning-box">
            <strong>æœ€çµ‚çš„ãªä½¿ã„æ–¹:</strong><br>
            ã“ã®ã‚·ã‚¹ãƒ†ãƒ ã¯ã€2ã¤ã®ãƒ‡ãƒã‚¤ã‚¹ï¼ˆPCã¨ã‚¹ãƒãƒ›ãªã©ï¼‰ã§å‹•ä½œã™ã‚‹ã‚ˆã†ã«è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ã€‚<br>
            1. <strong>å—ä¿¡å´ãƒ‡ãƒã‚¤ã‚¹</strong>ã§ã€Œå—ä¿¡é–‹å§‹ã€ã‚’æŠ¼ã—ã¾ã™ã€‚<br>
            2. <strong>é€ä¿¡å´ãƒ‡ãƒã‚¤ã‚¹</strong>ã§ã€Œé€ä¿¡ã€ã‚’æŠ¼ã—ã€å—ä¿¡å´ã®ãƒã‚¤ã‚¯ã«ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ã‚’è¿‘ã¥ã‘ã¦ãã ã•ã„ã€‚
        </div>
        <div class="section">
            <h2>ğŸ“¤ é€ä¿¡å´ (Sender)</h2>
            <input type="text" id="urlInput" value="This Works!" style="width: 300px;">
            <button id="sendButton">é€ä¿¡</button>
            <p>ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: <span id="status-tx">å¾…æ©Ÿä¸­</span></p>
        </div>
        <div class="section">
            <h2>ğŸ“¥ å—ä¿¡å´ (Receiver)</h2>
            <button id="listenButton">å—ä¿¡é–‹å§‹</button>
            <button id="resetButton">ãƒªã‚»ãƒƒãƒˆ</button>
            <p>ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: <span id="status-rx">å¾…æ©Ÿä¸­</span></p>
            <p><b>å—ä¿¡ãƒã‚¤ãƒŠãƒª:</b> <span id="binaryResult"></span></p>
            <p><b>å—ä¿¡ãƒ†ã‚­ã‚¹ãƒˆ:</b> <span id="textResult"></span></p>
            <p style="font-size: 0.8em; color: #666; margin-top: 15px;">åŒæœŸãƒ”ãƒ¼ã‚¯: <span id="debug-sync">0.0</span> |
                ãƒ‡ãƒ¼ã‚¿0ãƒ”ãƒ¼ã‚¯: <span id="debug-data0">0.0</span> | ãƒ‡ãƒ¼ã‚¿1ãƒ”ãƒ¼ã‚¯: <span id="debug-data1">0.0</span></p>
        </div>
    </div>

    <script>
        // === Final Version è¨­å®š: å¯è´åŸŸãƒãƒ£ãƒ¼ãƒ— ===
        let SAMPLE_RATE = 48000;
        const SYNC_FREQ_START = 2000, SYNC_FREQ_END = 6000, SYNC_DURATION_MS = 200;
        const DATA_FREQ_LOW = 4000, DATA_FREQ_HIGH = 5000;
        const BIT_DURATION_MS = 40, CHAR_PAUSE_MS = 40;
        const SCRIPT_PROCESSOR_SIZE = 4096;
        const CORRELATION_THRESHOLD = 0.4;
        const GAIN_VALUE = 5.0;

        // UIè¦ç´ 
        const sendButton = document.getElementById('sendButton'), urlInput = document.getElementById('urlInput'),
            statusTx = document.getElementById('status-tx'), listenButton = document.getElementById('listenButton'),
            statusRx = document.getElementById('status-rx'), binaryResult = document.getElementById('binaryResult'),
            textResult = document.getElementById('textResult'), debugSync = document.getElementById('debug-sync'),
            debugData0 = document.getElementById('debug-data0'), debugData1 = document.getElementById('debug-data1'),
            resetButton = document.getElementById('resetButton');

        let txAudioContext;
        function playChirp(startFreq, endFreq, durationMs) {
            if (!txAudioContext || txAudioContext.state === 'closed') txAudioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SAMPLE_RATE });
            const gainNode = txAudioContext.createGain(); gainNode.gain.value = GAIN_VALUE;
            gainNode.connect(txAudioContext.destination);
            const oscillator = txAudioContext.createOscillator();
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(startFreq, txAudioContext.currentTime);
            oscillator.frequency.linearRampToValueAtTime(endFreq, txAudioContext.currentTime + durationMs / 1000);
            oscillator.connect(gainNode); oscillator.start();
            oscillator.stop(txAudioContext.currentTime + durationMs / 1000);
            return new Promise(resolve => setTimeout(resolve, durationMs));
        }
        sendButton.onclick = async () => {
            statusTx.textContent = 'é€ä¿¡ä¸­...'; sendButton.disabled = true;
            console.log('é€ä¿¡: åŒæœŸä¿¡å· (2-6kHz)');
            await playChirp(SYNC_FREQ_START, SYNC_FREQ_END, SYNC_DURATION_MS);
            const textToSend = urlInput.value;
            const binaryChars = textToSend.split('').map(char => ('0'.repeat(8) + char.charCodeAt(0).toString(2)).slice(-8));
            for (const charBits of binaryChars) {
                for (const bit of charBits) {
                    if (bit === '0') await playChirp(DATA_FREQ_HIGH, DATA_FREQ_LOW, BIT_DURATION_MS);
                    else await playChirp(DATA_FREQ_LOW, DATA_FREQ_HIGH, BIT_DURATION_MS);
                }
                await new Promise(resolve => setTimeout(resolve, CHAR_PAUSE_MS));
            }
            statusTx.textContent = 'é€ä¿¡å®Œäº†'; sendButton.disabled = false;
        };

        // === å—ä¿¡å´ãƒ­ã‚¸ãƒƒã‚¯ ===
        let rxAudioContext, microphoneStream, isListening = false, receiveState = 'IDLE',
            syncTemplate, data0Template, data1Template, scriptProcessor, continuousInputBuffer;

        function generateChirpTemplate(sampleRate, startFreq, endFreq, durationMs) {
            const durationSec = durationMs / 1000, bufferSize = Math.ceil(sampleRate * durationSec);
            const buffer = new Float32Array(bufferSize);
            for (let i = 0; i < bufferSize; i++) {
                const t = i / sampleRate;
                const phase = 2 * Math.PI * (startFreq * t + (endFreq - startFreq) * t * t / (2 * durationSec));
                buffer[i] = Math.sin(phase);
            }
            return buffer;
        }
        function normalizedCrossCorrelation(signal, template) {
            let maxCorr = 0; const n = signal.length, m = template.length; if (n < m) return 0;
            const templateMean = template.reduce((a, b) => a + b) / m;
            const templateStdDev = Math.sqrt(template.reduce((sum, val) => sum + Math.pow(val - templateMean, 2), 0));
            if (templateStdDev === 0) return 0;
            for (let i = 0; i <= n - m; i++) {
                const subSignal = signal.slice(i, i + m);
                const subSignalMean = subSignal.reduce((a, b) => a + b) / m;
                const subSignalStdDev = Math.sqrt(subSignal.reduce((sum, val) => sum + Math.pow(val - subSignalMean, 2), 0));
                if (subSignalStdDev === 0) continue; let corr = 0;
                for (let j = 0; j < m; j++) corr += (subSignal[j] - subSignalMean) * (template[j] - templateMean);
                maxCorr = Math.max(maxCorr, corr / (templateStdDev * subSignalStdDev));
            }
            return maxCorr;
        }

        let receivedBinary = '', nextBitTime = 0, receivedText = '', lastSyncTime = 0;

        function processAudio(event) {
            if (!isListening) return;
            const inputData = event.inputBuffer.getChannelData(0);
            const now = rxAudioContext.currentTime;
            const tempBuffer = new Float32Array(continuousInputBuffer.length);
            tempBuffer.set(continuousInputBuffer.slice(inputData.length));
            tempBuffer.set(inputData, continuousInputBuffer.length - inputData.length);
            continuousInputBuffer = tempBuffer;
            if (receiveState === 'IDLE') {
                const correlation = normalizedCrossCorrelation(continuousInputBuffer, syncTemplate);
                debugSync.textContent = correlation.toFixed(4);
                if (correlation > CORRELATION_THRESHOLD && (now - lastSyncTime) > 1.0) {
                    lastSyncTime = now;
                    console.log(`%cåŒæœŸä¿¡å·æ¤œå‡ºï¼ç›¸é–¢ãƒ”ãƒ¼ã‚¯: ${correlation.toFixed(4)}`, 'color: green; font-weight: bold;');
                    statusRx.textContent = 'ãƒ‡ãƒ¼ã‚¿å—ä¿¡ä¸­...'; receiveState = 'RECEIVING';
                    receivedBinary = ''; binaryResult.textContent = ''; receivedText = ''; textResult.textContent = '';
                    nextBitTime = now + (SYNC_DURATION_MS / 1000);
                }
            } else if (receiveState === 'RECEIVING') {
                if (now >= nextBitTime) {
                    const analysisBuffer = continuousInputBuffer.slice(-data0Template.length);
                    const corr0 = normalizedCrossCorrelation(analysisBuffer, data0Template);
                    const corr1 = normalizedCrossCorrelation(analysisBuffer, data1Template);
                    debugData0.textContent = corr0.toFixed(4); debugData1.textContent = corr1.toFixed(4);
                    const bit = corr0 > corr1 ? '0' : '1';
                    console.log(`ãƒ“ãƒƒãƒˆæ¤œå‡º: ${bit} (Corr0: ${corr0.toFixed(3)}, Corr1: ${corr1.toFixed(3)})`);
                    receivedBinary += bit; binaryResult.textContent = receivedBinary;
                    if (receivedBinary.length % 8 === 0) {
                        const char = String.fromCharCode(parseInt(receivedBinary.slice(-8), 2));
                        receivedText += char; textResult.textContent = receivedText;
                        console.log(`%cæ–‡å­—å—ä¿¡: "${char}"`, 'color: blue; font-weight: bold;');
                        nextBitTime += (BIT_DURATION_MS + CHAR_PAUSE_MS) / 1000;
                    } else { nextBitTime += BIT_DURATION_MS / 1000; }
                    if (now - lastSyncTime > 5) { console.log("å—ä¿¡ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ"); resetButton.onclick(); }
                }
            }
        }

        async function startListening() {
            if (isListening) return;
            statusRx.textContent = 'ãƒã‚¤ã‚¯æº–å‚™ä¸­...';
            try {
                const constraints = { audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false, sampleRate: 48000 }, video: false };
                microphoneStream = await navigator.mediaDevices.getUserMedia(constraints);
                rxAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                SAMPLE_RATE = rxAudioContext.sampleRate;
                console.log(`%cå®Ÿéš›ã®ã‚µãƒ³ãƒ—ãƒ«ãƒ¬ãƒ¼ãƒˆ: ${SAMPLE_RATE} Hz`, 'color: blue; font-size: 1.1em;');
                syncTemplate = generateChirpTemplate(SAMPLE_RATE, SYNC_FREQ_START, SYNC_FREQ_END, SYNC_DURATION_MS);
                data0Template = generateChirpTemplate(SAMPLE_RATE, DATA_FREQ_HIGH, DATA_FREQ_LOW, BIT_DURATION_MS);
                data1Template = generateChirpTemplate(SAMPLE_RATE, DATA_FREQ_LOW, DATA_FREQ_HIGH, BIT_DURATION_MS);
                continuousInputBuffer = new Float32Array(SCRIPT_PROCESSOR_SIZE * 2);
                const source = rxAudioContext.createMediaStreamSource(microphoneStream);
                const gainNode = rxAudioContext.createGain(); gainNode.gain.value = GAIN_VALUE;
                scriptProcessor = rxAudioContext.createScriptProcessor(SCRIPT_PROCESSOR_SIZE, 1, 1);
                scriptProcessor.onaudioprocess = processAudio;
                source.connect(gainNode); gainNode.connect(scriptProcessor);
                isListening = true; listenButton.textContent = 'å—ä¿¡åœæ­¢';
                statusRx.textContent = 'åŒæœŸä¿¡å·å¾…æ©Ÿä¸­...'; console.log('å—ä¿¡é–‹å§‹ã€åŒæœŸä¿¡å·ã‚’å¾…ã£ã¦ã„ã¾ã™...');
            } catch (err) { console.error("ãƒã‚¤ã‚¯ã®èµ·å‹•ã«å¤±æ•—:", err); statusRx.textContent = "ãƒã‚¤ã‚¯ã‚¨ãƒ©ãƒ¼"; }
        }
        function stopListening() { if (!isListening) return; isListening = false; if (microphoneStream) microphoneStream.getTracks().forEach(track => track.stop()); if (scriptProcessor) scriptProcessor.disconnect(); if (rxAudioContext) rxAudioContext.close().catch(e => console.error(e)); listenButton.textContent = 'å—ä¿¡é–‹å§‹'; statusRx.textContent = 'åœæ­¢ä¸­'; console.log('å—ä¿¡åœæ­¢'); }
        resetButton.onclick = () => { receiveState = 'IDLE'; receivedBinary = ''; binaryResult.textContent = ''; receivedText = ''; statusRx.textContent = isListening ? 'åŒæœŸä¿¡å·å¾…æ©Ÿä¸­...' : 'ãƒªã‚»ãƒƒãƒˆå®Œäº†'; };
        listenButton.onclick = () => isListening ? stopListening() : startListening();
    </script>
</body>

</html>