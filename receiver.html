<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>音響通信 - 受信側</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 1em;
        }

        .container {
            max-width: 600px;
            margin: auto;
        }

        .section {
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }

        h2 {
            margin-top: 0;
        }

        button {
            padding: 10px 15px;
            font-size: 16px;
            margin-right: 8px;
        }

        #stopButton {
            background: #dc3545;
            color: white;
        }

        #resetButton {
            background: #ffc107;
        }

        #status-rx {
            color: #007bff;
        }

        #binaryResult {
            word-break: break-all;
        }

        #textResult {
            color: #dc3545;
            font-weight: bold;
        }

        #charLog {
            height: 100px;
            overflow-y: scroll;
            border: 1px solid #eee;
            padding: 5px;
            background: #f8f9fa;
        }

        .log-entry {
            margin-bottom: 3px;
        }

        .log-tx {
            color: #007bff;
            font-weight: bold;
        }

        .log-rx {
            color: #dc3545;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>音響通信 (受信専用)</h1>

        <div class="section">
            <h2>受信側 (Receiver)</h2>
            <button id="stopButton">受信停止</button>
            <button id="resetButton">リセット</button>
            <p>ステータス: <span id="status-rx">初期化中...</span></p>
            <p><b>受信バイナリ:</b> <span id="binaryResult"></span></p>
            <p><b>受信テキスト:</b> <span id="textResult"></span></p>

            <h4>受信ログ (比較用)</h4>
            <div id="charLog"></div>

            <p style="font-size: 0.8em; color: #666; margin-top: 15px;">（HTMLデバッグ: <span id="debug-volume">...</span>）
            </p>
        </div>
    </div>

    <script>
        // --- 共通設定 (v25の安定設定) ---
        const FREQ_0 = 1750; // '0' の周波数 (Hz)
        const FREQ_1 = 2000; // '1' の周波数 (Hz)
        const FREQ_START = 1500; // 開始信号
        const FREQ_END = 2250; // 終了信号 (分離)

        const START_DURATION = 500; // 開始信号の長さ (ミリ秒)
        const END_DURATION = 500;   // 終了信号の長さ (ミリ秒)
        const BIT_DURATION = 400; // 1ビットあたりの再生時間 (ミリ秒)
        const CHAR_PAUSE = 400; // 文字間ポーズ

        const THRESHOLD = -85; // 成功したしきい値を維持
        // ---

        // === UI要素 (グローバル) ===
        const statusRx = document.getElementById('status-rx');
        const binaryResult = document.getElementById('binaryResult');
        const textResult = document.getElementById('textResult');
        const debugVolume = document.getElementById('debug-volume');
        const resetButton = document.getElementById('resetButton');
        const charLog = document.getElementById('charLog');
        const stopButton = document.getElementById('stopButton'); // ▼

        // === 受信側 (RECEIVER) のロジック ===
        let rxAudioContext;
        let analyser;
        let microphoneStream;
        let dataArray;
        let isListening = false;
        let receivedBinary = '';

        let receiveState = 'IDLE';
        let nextBitStartTime = 0;
        let expectedChars = 0;
        let bitsReceived = 0;
        let absoluteStartTime = 0;

        function binaryToString(bin) {
            let str = '';
            for (let i = 0; i < bin.length; i += 8) {
                const byte = bin.substr(i, 8);
                if (byte.length === 8) {
                    str += String.fromCharCode(parseInt(byte, 2));
                }
            }
            return str;
        }

        function analyze() {
            if (!isListening) return;
            requestAnimationFrame(analyze);

            analyser.getFloatFrequencyData(dataArray);

            const targetBinSize = rxAudioContext.sampleRate / analyser.fftSize;

            const freq0Index = Math.round(FREQ_0 / targetBinSize);
            const freq1Index = Math.round(FREQ_1 / targetBinSize);
            const freqStartIndex = Math.round(FREQ_START / targetBinSize);
            const freqEndIndex = Math.round(FREQ_END / targetBinSize);

            const freq0Db = dataArray[freq0Index];
            const freq1Db = dataArray[freq1Index];
            const freqStartDb = dataArray[freqStartIndex];
            const freqEndDb = dataArray[freqEndIndex];

            const now = Date.now();

            debugVolume.textContent = `Start(1.5k): ${freqStartDb.toFixed(1)}, F0(1.75k): ${freq0Db.toFixed(1)}, F1(2.0k): ${freq1Db.toFixed(1)}, End(2.25k): ${freqEndDb.toFixed(1)}`;

            // 1. 待機状態 (IDLE): スタート信号を探す
            if (receiveState === 'IDLE') {
                if (freqStartDb > THRESHOLD && freqStartDb > freq0Db && freqStartDb > freq1Db && freqStartDb > freqEndDb) {
                    console.log(`--- スタート信号(1.5k)を検出！ (${freqStartDb.toFixed(1)}dB) ---`);
                    statusRx.textContent = '受信開始！';
                    receiveState = 'RECEIVING';

                    // ▼▼▼ 注意：送信側のタブから文字数を取得できないため、文字数不明で受信します ▼▼▼
                    expectedChars = 0; // 不明
                    expectedBitsTotal = 0; // 不明
                    bitsReceived = 0;

                    receivedBinary = '';
                    binaryResult.textContent = '';
                    textResult.textContent = '';

                    absoluteStartTime = now;
                    nextBitStartTime = absoluteStartTime + (START_DURATION - 50) + (BIT_DURATION / 2);
                }
            }
            // 2. 受信状態 (RECEIVING): 決まった時刻にのみ判定
            else if (receiveState === 'RECEIVING') {

                if (now > nextBitStartTime) {

                    let bit = '';

                    // 終了信号(2.25k)か？
                    if (freqEndDb > THRESHOLD && freqEndDb > freqStartDb && freqEndDb > freq0Db && freqEndDb > freq1Db) {
                        console.log(`--- 終了信号(2.25k)を検出！ (${freqEndDb.toFixed(1)}dB) ---`);
                        statusRx.textContent = '受信完了（終了信号受信）';
                        receiveState = 'IDLE';
                        return;
                    }

                    // '0' の信号(1.75k)か？
                    else if (freq0Db > THRESHOLD && freq0Db > freqStartDb && freq0Db > freq1Db && freq0Db > freqEndDb) {
                        bit = '0';
                        console.log(`ビット ${bitsReceived}: '0' (1.75k) を検出 (${freq0Db.toFixed(1)}dB)`);
                    }
                    // '1' の信号(2.0k)か？
                    else if (freq1Db > THRESHOLD && freq1Db > freqStartDb && freq1Db > freq0Db && freq1Db > freqEndDb) {
                        bit = '1';
                        console.log(`ビット ${bitsReceived}: '1' (2.0k) を検出 (${freq1Db.toFixed(1)}dB)`);
                    }
                    else {
                        bit = '?'; // 不明なビット
                        console.log(`ビット ${bitsReceived}: 信号検出失敗 (音量不足)`);
                    }

                    receivedBinary += bit;
                    binaryResult.textContent = receivedBinary;
                    bitsReceived++;

                    // ▼ 次のビットの「絶対時刻」を再計算
                    const charsSoFar = Math.floor(bitsReceived / 8);
                    const pausesSoFar = charsSoFar;
                    nextBitStartTime = absoluteStartTime + (START_DURATION - 50) + (BIT_DURATION * (bitsReceived + 0.5)) + (CHAR_PAUSE * pausesSoFar);

                    if (bitsReceived > 0 && bitsReceived % 8 === 0) {
                        const lastByte = receivedBinary.slice(-8);
                        const lastChar = binaryToString(lastByte);

                        textResult.textContent = binaryToString(receivedBinary);

                        const logEntry = document.createElement('div');
                        logEntry.className = 'log-entry log-rx';
                        logEntry.textContent = `[受信 R:] ${lastChar} (バイナリ: ${lastByte})`;
                        charLog.appendChild(logEntry);
                        charLog.scrollTop = charLog.scrollHeight;

                        console.log(`--- 1文字認識: ${lastChar} ---`);
                    }
                }
            }
            // 3. 終了待機状態 (WAIT_END) - このロジックは文字数不明のため使われない
        }

        async function startListening() {
            if (isListening) return; // 既に開始している場合は何もしない

            try {
                const constraints = {
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    },
                    video: false
                };
                microphoneStream = await navigator.mediaDevices.getUserMedia(constraints);

                rxAudioContext = new (window.AudioContext || window.webkitAudioContext)();

                analyser = rxAudioContext.createAnalyser();
                analyser.fftSize = 2048;
                dataArray = new Float32Array(analyser.frequencyBinCount);

                const source = rxAudioContext.createMediaStreamSource(microphoneStream);
                source.connect(analyser);

                isListening = true;
                stopButton.textContent = '受信停止';
                statusRx.textContent = '開始信号を待っています...';
                analyze();

            } catch (err) {
                alert('マイクの取得に失敗しました: ' + err.message);
                statusRx.textContent = 'マイク取得エラー';
            }
        }

        function stopListening() {
            isListening = false;
            receiveState = 'IDLE';
            stopButton.textContent = '受信再開';
            statusRx.textContent = '停止中';
            if (microphoneStream) {
                microphoneStream.getTracks().forEach(track => track.stop());
            }
            if (rxAudioContext && rxAudioContext.state !== 'closed') {
                rxAudioContext.close();
            }
        }

        // ▼▼▼ 停止/再開ボタンのロジック ▼▼▼
        stopButton.onclick = () => {
            if (isListening) {
                stopListening();
            } else {
                startListening();
            }
        };

        resetButton.onclick = () => {
            receivedBinary = '';
            binaryResult.textContent = '';
            textResult.textContent = '';
            charLog.innerHTML = '';
            statusRx.textContent = 'リセットしました';
            if (isListening) {
                receiveState = 'IDLE';
                bitsReceived = 0;
                expectedChars = 0;
                absoluteStartTime = 0;
            }
        };

        // ▼▼▼ ページ読み込み時に自動で受信開始 ▼▼▼
        // (ブラウザがマイク許可をポップアップで尋ねます)
        // startListening();

    </script>
</body>

</html>